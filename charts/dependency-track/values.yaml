---
common:
  nameOverride: ""
  fullnameOverride: ""
  image:
    registry: docker.io
    pullSecrets: []
  secretKey:
    # -- Whether the chart should generate a secret key upon deployment.
    createSecret: false
    # -- Use the secret key defined in an existing secret.
    existingSecretName: ""

apiServer:
  annotations: {}
  image:
    repository: dependencytrack/apiserver
    tag: ~
    pullPolicy: IfNotPresent
  command: []
  args: []
  resources:
    requests:
      cpu: "2"
      memory: 5Gi
    limits:
      cpu: "4"
      memory: 5Gi
  persistentVolume:
    enabled: false
    className: ""
    size: 5Gi
  extraEnv: {}
  extraEnvFrom: []
  extraContainers: []
  tolerations: []
  probes:
    liveness:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
    readiness:
      failureThreshold: 3
      initialDelaySeconds: 10
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
  service:
    type: ClusterIP
    nodePort: ~
    annotations: {}
  serviceMonitor:
    enabled: false
    namespace: monitoring
    scrapeInternal: 15s
    scrapeTimeout: 30s
  initContainers: []
  # Use the following to fix permissions on the /data volume.
  # initContainers:
  #   - name: fix-permissions
  #     image: docker.io/library/busybox
  #     command:
  #       - sh
  #       - -c
  #       - |
  #         chown -R 1000:1000 /data
  #     volumeMounts:
  #       - name: data
  #         mountPath: /data
  #     securityContext:
  #       capabilities:
  #         add:
  #         - CHOWN
  #       runAsNonRoot: false
  #       runAsUser: 0
  #       seccompProfile:
  #         type: RuntimeDefault

frontend:
  replicaCount: 1
  annotations: {}
  image:
    repository: dependencytrack/frontend
    tag: 4.10.0
    pullPolicy: IfNotPresent
  command: []
  args: []
  resources:
    requests:
      cpu: 150m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 128Mi
  extraEnv: {}
  extraEnvFrom: []
  extraContainers: []
  tolerations: []
  probes:
    liveness:
      failureThreshold: 3
      initialDelaySeconds: 5
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
    readiness:
      failureThreshold: 3
      initialDelaySeconds: 5
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
  service:
    type: ClusterIP
    nodePort: ~
    annotations: {}
  apiBaseUrl: ""
  initContainers: []

tls:
  # -- Enable TLS transport
  enabled: false
  # -- Auto-generate self-signed certificates
  autoGenerated: true
  existingSecret: ""
  certFilename: tls.crt
  certKeyFilename: tls.key
  certCAFilename: ca.crt
  cert: ""
  key: ""
  ca: ""
ingress:
  # -- Set to true to enable ingress record generation
  enabled: false

  # -- Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  selfSigned: false

  # -- Ingress path type
  pathType: ImplementationSpecific

  # -- Force Ingress API version (automatically detected if not set)
  apiVersion: ""

  # -- Default host for the ingress resource
  hostname: dependency-track.local.gd

  # -- The URL Path to **dependency-track**. You may need to set this to `/*` in order to use this with ALB ingress controllers.
  path: /

  # -- Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  # For a full list of possible ingress annotations. Use this parameter to set the required annotations for cert-manager, see
  # ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  annotations: {}
  # cert-manager.io/cluster-issuer: cluster-issuer-name

  # -- Set the ingerssClassName on the ingress record for k8s 1.18+
  # This is supported in **Kubernetes 1.18+** and required if you have more than one `IngressClass` marked as the `default` for your cluster.
  # ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
  ingressClassName: ""

  # -- Create TLS Secret
  # TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
  # You can use the `ingress.secrets` parameter to create this TLS secret or relay on cert-manager to create it
  tls: false

  # -- Adds **www** subdomain to default certificate
  # Creates tls host with ingress.hostname: `{{ print "www.%s" .Values.ingress.hostname }}`
  # Is enabled if "`nginx.ingress.kubernetes.io/from-to-www-redirect`" is "`true`"
  tlsWwwPrefix: false

  # -- The list of additional hostnames to be covered with this ingress record.
  # Most likely the hostname above will be enough, but in the event more hosts are needed, this is an array
  extraHosts: []
  # - name: dt.local.gd
  #   path: /

  # -- Any additional arbitrary paths that may need to be added to the ingress under the main host.
  # For example: The ALB ingress controller requires a special rule for handling SSL redirection.
  extraPaths: []
  # - path: /*
  #   backend:
  #     serviceName: ssl-redirect
  #     servicePort: use-annotation

  # -- The tls configuration for additional hostnames to be covered with this ingress record.
  # see: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  extraTls: []
  # - hosts:
  #     - dt.local.gd
  #   secretName: dt.local.gd-tls

  # -- If you're providing your own certificates, please use this to add the certificates as secrets
  # key and certificate should start with `-----BEGIN CERTIFICATE-----` or
  # `-----BEGIN RSA PRIVATE KEY-----` and name should line up with a `tlsSecret` set further up.
  # If you're using **cert-manager**, this is unneeded, as it will create the **secret** for you if it is not set.
  # It is also possible to create and manage the certificates outside of this helm chart.
  secrets: []
  # - name: dt.local.gd-tls
  #   key:
  #   certificate:

  # -- The list of additional rules to be added to this ingress record. Evaluated as a template.
  # Useful when looking for additional customization, such as using different backend
  extraRules: []
